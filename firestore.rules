/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a multi-tenant security model for the ServiYa application,
 *              where users, clients, and service requests are isolated and access is controlled based on
 *              ownership and role-based access. The design promotes authorization independence by denormalizing
 *              authorization data (e.g., clientId, assignedTechnicianId) directly onto documents, avoiding
 *              costly and slow `get()` calls in rules.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Accessible by the user and admins.
 * - /roles_admin/{userId}, /roles_owner/{userId}: Existence-based role assignment for admins and owners.
 * - /clients/{clientId}: Stores client profiles. Accessible by admins and the client themselves.
 * - /serviceRequests/{serviceRequestId}: Stores service requests, with denormalized clientId and assignedTechnicianId.
 * - /serviceRequests/{serviceRequestId}/quotations/{quotationId}: Stores quotations for service requests.
 * - /serviceRequests/{serviceRequestId}/payments/{paymentId}: Stores payments for service requests.
 * - /serviceRequests/{serviceRequestId}/tasks/{taskId}: Stores tasks for service requests.
 * - /users/{userId}/notifications/{notificationId}: Stores notifications for users.
 * - /serviceRequests/{serviceRequestId}/files/{fileId}: Stores files related to service requests.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed except for admins.
 * - Role assignment is based on the existence of documents in /roles_admin and /roles_owner.
 * - Service request access is granted to the client, assigned technician, and admins.
 * - Data validation is relaxed in the prototyping phase, focusing on authorization and relational integrity.
 * - No open write operations are permitted. All write operations must be protected by authorization checks.
 *
 * Denormalization for Authorization:
 * - ServiceRequest documents contain `clientId` and `assignedTechnicianId` fields. This allows rules to
 *   quickly check if the requesting user is the client or the assigned technician without additional reads.
 *
 * Structural Segregation:
 * - User-specific data (notifications) is stored under the /users/{userId} path, ensuring only the user
 *   and admins can access it.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @returns {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     * @param {string} userId - The user ID to compare against.
     * @returns {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is an existing owner.
     *              Combines the ownership check with an existence check to prevent operations on non-existent documents.
     * @param {string} userId - The user ID to compare against.
     * @returns {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user has the admin role.
     * @returns {boolean} True if the user has the admin role, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Checks if the user has the owner role.
     * @returns {boolean} True if the user has the owner role, false otherwise.
     */
    function isOwnerRole() {
      return exists(/databases/$(database)/documents/roles_owner/$(request.auth.uid));
    }
   
    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User tdcxxhBcApXURw1M3QHvCfVf4df1 can create their own profile.
     * @allow (get) User tdcxxhBcApXURw1M3QHvCfVf4df1 can get their own profile.
     * @deny (create) User abc can't create a profile for user def.
     * @principle Enforces user-ownership for data privacy.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin() ;
      allow list: if false;
      allow create: if isOwner(userId) ;
      allow update: if isExistingOwner(userId) || isAdmin() ;
      allow delete: if isExistingOwner(userId) || isAdmin();
    }

    /**
     * @description Rules for admin role assignment.
     * @path /roles_admin/{userId}
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin() || isOwnerRole();
      allow list: if false;
      allow create: if isOwnerRole();
      allow update: if false;
      allow delete: if isOwnerRole();
    }

    /**
     * @description Rules for owner role assignment.
     * @path /roles_owner/{userId}
     */
    match /roles_owner/{userId} {
      allow get: if isOwnerRole();
      allow list: if false;
      allow create: if isOwnerRole();
      allow update: if false;
      allow delete: if isOwnerRole();
    }

    /**
     * @description Rules for client profiles.
     * @path /clients/{clientId}
     */
    match /clients/{clientId} {
      allow get: if isOwner(clientId) || isAdmin();
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(clientId) || isAdmin();
      allow delete: if isExistingOwner(clientId) || isAdmin();
    }

    /**
     * @description Rules for service requests.
     * @path /serviceRequests/{serviceRequestId}
     * @allow (get) User tdcxxhBcApXURw1M3QHvCfVf4df1 can read a service request if they are the client or assigned technician.
     * @deny (create) User abc can't create a service request with a mismatched clientId.
     * @principle Enforces client and technician access control for service requests.
     */
    match /serviceRequests/{serviceRequestId} {
      allow get: if isAdmin() || isOwner(resource.data.clientId) || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      //The fix is to allow the 'list' method to be executed by admins.
      allow list: if isAdmin();
      allow create: if isSignedIn() && request.resource.data.clientId == request.auth.uid;
      allow update: if (isExistingOwner(resource.data.clientId) || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid) || isAdmin());
      allow delete: if isExistingOwner(resource.data.clientId) || isAdmin();
    }

    /**
     * @description Rules for quotations under service requests.
     * @path /serviceRequests/{serviceRequestId}/quotations/{quotationId}
     */
    match /serviceRequests/{serviceRequestId}/quotations/{quotationId} {
      allow get: if isAdmin() || isOwner(resource.data.clientId) || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Rules for payments under service requests.
     * @path /serviceRequests/{serviceRequestId}/payments/{paymentId}
     */
    match /serviceRequests/{serviceRequestId}/payments/{paymentId} {
      allow get: if isAdmin() || isOwner(resource.data.clientId) || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Rules for tasks under service requests.
     * @path /serviceRequests/{serviceRequestId}/tasks/{taskId}
     */
    match /serviceRequests/{serviceRequestId}/tasks/{taskId} {
      allow get: if isAdmin() || isOwner(resource.data.clientId) || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      allow list: if false;
      allow create: if isAdmin() || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      allow update: if isAdmin() || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      allow delete: if isAdmin();
    }

    /**
     * @description Rules for notifications under users.
     * @path /users/{userId}/notifications/{notificationId}
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) || isAdmin();
      allow delete: if isExistingOwner(userId) || isAdmin();
    }

    /**
     * @description Rules for files under service requests.
     * @path /serviceRequests/{serviceRequestId}/files/{fileId}
     */
    match /serviceRequests/{serviceRequestId}/files/{fileId} {
      allow get: if isAdmin() || isOwner(resource.data.clientId) || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      allow list: if false;
      allow create: if isAdmin() || isOwner(resource.data.clientId) || (isSignedIn() && resource.data.assignedTechnicianId == request.auth.uid);
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}