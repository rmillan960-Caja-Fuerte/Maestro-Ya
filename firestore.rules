/**
 * @file This Firestore Security Rules file enforces a role-based and ownership-based access control model for the ServiYa application.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure access to user data and collaborative resources. It enforces strict ownership for user-specific data and employs a role-based access control (RBAC) model for administrative functions, combined with Shared Access using denormalized IDs.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`.
 * - Admin/Owner user role is granted by existing documents in `/roles_admin/{userId}` and `/roles_owner/{userId}`.
 * - Client profiles are stored under `/clients/{clientId}`.
 * - Service requests are stored under `/serviceRequests/{serviceRequestId}`.
 * - Quotations, payments, and tasks are stored as subcollections under their respective service requests.
 * - Notifications are stored as subcollections under the respective user.
 * - Files are stored as subcollections under their respective service requests.
 *
 * Key Security Decisions:
 * - User listing is disabled globally.
 * - Roles are determined by the existence of documents in specific collections (`/roles_admin/{userId}`, `/roles_owner/{userId}`).
 * - Service requests are accessible to the client who created them, assigned technician, and admins, using denormalized fields.
 *
 * Denormalization for Authorization:
 * - Service requests include the `clientId` and `assignedTechnicianId` fields to enable direct authorization checks without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Validates user authentication for all protected resources.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user's ID matches the provided user ID.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user ownership for data stored under user-specific paths.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

     /**
      * @description Checks if the current user is an existing owner of a document (isSignedIn, isOwner, and resource exists).
      * @path N/A
      * @allow N/A
      * @deny N/A
      * @principle Protects update and delete operations by verifying both ownership and document existence.
      */
    function isExistingOwner(userId) {
      return isOwner(userId) && exists(resource);
    }

    /**
     * @description Checks if the current user has admin privileges by checking for the existance of a `/roles_admin/{userId}` document.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Uses a DBAC model: roles are stored as documents in the database.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Checks if the current user has owner privileges by checking for the existance of a `/roles_owner/{userId}` document.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Uses a DBAC model: roles are stored as documents in the database.
     */
    function isOwnerRole() {
      return exists(/databases/$(database)/documents/roles_owner/$(request.auth.uid));
    }

    /**
     * @description Enforces that a field cannot be changed after document creation.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Prevents modification of critical relational fields.
     */
    function isImmutable(field) {
        return request.resource.data[field] == resource.data[field];
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.id: 'user123'
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their profile.
     *   - request.auth.uid: 'user123'
     * @allow (get) Admin user reads any profile.
     *   - User exists at /roles_admin/{userId}
     * @deny (create) User attempts to create a profile with a mismatched ID.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.id: 'user456'
     * @deny (update, delete) User with ID 'user123' attempts to update/delete another user's profile.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership and admin overrides.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingOwner(userId);
      allow delete: if isOwner(userId) && isExistingOwner(userId);
    }

    /**
     * @description Rules for admin role assignment.
     * @path /roles_admin/{userId}
     * @allow (create) Owner user assigns admin role.
     *   - User exists at /roles_owner/{ownerId}
     * @allow (get) Any user can check if a user is an admin.
     * @deny (create) Non-owner user attempts to assign admin role.
     *   - User does not exist at /roles_owner/{ownerId}
     * @deny (update, delete) Only owner user can modify the admin role.
     * @principle Owner-only role management.
     */
    match /roles_admin/{userId} {
      allow get: if isSignedIn(); // Anyone can check if a user is an admin
      allow list: if false;
      allow create: if isOwnerRole();
      allow update: if false;
      allow delete: if isOwnerRole();
    }

    /**
     * @description Rules for owner role assignment.
     * @path /roles_owner/{userId}
     * @allow (create) Initial owner assignment (usually done via backend).
     * @allow (get) Any user can check if a user is an owner.
     * @deny (update, delete) No client-side modification of owner roles.
     * @principle Backend-controlled owner management.
     */
    match /roles_owner/{userId} {
      allow get: if isSignedIn(); // Anyone can check if a user is an owner
      allow list: if false;
      allow create: if isAdmin(); // Only Admins can create Owners
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rules for client profiles.
     * @path /clients/{clientId}
     * @allow (create) Any signed-in user can create a client profile for themself.
     *   - request.auth.uid == clientId
     * @allow (get) Client can read their own profile or an admin can read any client profile.
     *   - request.auth.uid == clientId OR isAdmin()
     * @allow (update, delete) Client can update/delete their own profile.
     *   - request.auth.uid == clientId
     * @deny (update, delete) Non-admin user attempts to modify another client's profile.
     *   - request.auth.uid != clientId
     * @principle Client-owned data with admin access.
     */
    match /clients/{clientId} {
      allow get: if isOwner(clientId) || isAdmin();
      allow list: if false;
      allow create: if isOwner(clientId) && request.resource.data.id == clientId;
      allow update: if isOwner(clientId) && isExistingOwner(clientId);
      allow delete: if isOwner(clientId) && isExistingOwner(clientId);
    }

    /**
     * @description Rules for service requests.
     * @path /serviceRequests/{serviceRequestId}
     * @allow (get, list) Public read access.
     * @allow (create) Any signed-in user can create a service request. Must set clientId to request.auth.uid.
     * @allow (update, delete) Only the client or an admin can modify a service request.
     * @principle Public read with owner-only writes.
     */
    match /serviceRequests/{serviceRequestId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.clientId == request.auth.uid;
      allow update: if isOwner(resource.data.clientId) || isAdmin();
      allow delete: if isOwner(resource.data.clientId) || isAdmin();
    }

    /**
     * @description Rules for quotations subcollection.
     * @path /serviceRequests/{serviceRequestId}/quotations/{quotationId}
     * @allow (get, list) Any signed-in user can read quotations.
     * @allow (create) Only admins can create quotations.
     * @allow (update, delete) Only admins can modify quotations.
     * @principle Admin-managed subcollection.
     */
    match /serviceRequests/{serviceRequestId}/quotations/{quotationId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Rules for payments subcollection.
     * @path /serviceRequests/{serviceRequestId}/payments/{paymentId}
     * @allow (get, list) Any signed-in user can read payments.
     * @allow (create) Only admins can create payments.
     * @allow (update, delete) Only admins can modify payments.
     * @principle Admin-managed subcollection.
     */
    match /serviceRequests/{serviceRequestId}/payments/{paymentId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Rules for tasks subcollection.
     * @path /serviceRequests/{serviceRequestId}/tasks/{taskId}
     * @allow (get, list) Any signed-in user can read tasks.
     * @allow (create) Only admins can create tasks.
     * @allow (update, delete) Only admins can modify tasks.
     * @principle Admin-managed subcollection.
     */
    match /serviceRequests/{serviceRequestId}/tasks/{taskId} {
      allow get, list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Rules for notifications subcollection.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (get, list) User can read their own notifications.
     * @allow (create) Any signed-in user can create a notification for themself.
     * @allow (update, delete) User can modify their own notifications.
     * @principle User-owned subcollection.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && isExistingOwner(userId);
      allow delete: if isOwner(userId) && isExistingOwner(userId);
    }

    /**
     * @description Rules for files subcollection.
     * @path /serviceRequests/{serviceRequestId}/files/{fileId}
     * @allow (get, list) Any signed-in user can read files.
     * @allow (create) Client who created the service request can create files.
     * @allow (update, delete) Client or admin can modify files.
     * @principle Service Request-related subcollection.
     */
    match /serviceRequests/{serviceRequestId}/files/{fileId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && get(/databases/$(database)/documents/serviceRequests/$(serviceRequestId)).data.clientId == request.auth.uid;
      allow update: if isOwner(get(/databases/$(database)/documents/serviceRequests/$(serviceRequestId)).data.clientId) || isAdmin();
      allow delete: if isOwner(get(/databases/$(database)/documents/serviceRequests/$(serviceRequestId)).data.clientId) || isAdmin();
    }
  }
}